{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/home-assistant.ts"],"sourcesContent":["'use server';\n\nfunction getHaConfig() {\n    // VIETTURIS: Lūdzu, aizstājiet šīs vērtības ar savām, ja nepieciešams!\n    const HA_URL = \"http://192.168.1.101:8123\"; \n    const HA_TOKEN = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjMTE4MjQwNjdlYTc0NWI5YTllOGFmMjcxNDViNWQwOSIsImlhdCI6MTc1NTc3NDk4NiwiZXhwIjoyMDcxMTM0OTg2fQ.tKjaJlcFP6TQteVXKV9YUIy5lY0UXR8Od5FSv-D-USo\";\n\n    if (!HA_URL || !HA_TOKEN || HA_TOKEN === \"AIZSTĀJIET_AR_SAVU_LONG_LIVED_TOKENU\") {\n        const errorMessage = `CRITICAL: getHaConfig() failed. HA_URL or HA_TOKEN is not set in src/services/home-assistant.ts. Values found: HA_URL=${HA_URL}, HA_TOKEN is ${HA_TOKEN ? 'present' : 'missing'}`;\n        console.error(errorMessage);\n        throw new Error('Home Assistant nav konfigurēts.');\n    }\n    \n    return { haUrl: HA_URL, haToken: HA_TOKEN };\n}\n\nconst LOCK_ENTITY_ID = 'switch.sonoff_1000e6fcb0_1';\nconst DOOR_SENSOR_ENTITY_ID = 'binary_sensor.1_durvis_durvis';\nconst HEAT_ENTITY_ID = 'switch.sonoff_1000e6fcb0_4';\nconst UV_ENTITY_ID = 'switch.sonoff_1000e6fcb0_3';\nconst FANS_ENTITY_ID = 'switch.sonoff_1000e6fcb0_2';\nconst MOTOR_ENTITY_ID = 'switch.sonoff_1000f85860';\n\nconst CLEANING_CYCLE_DURATION_MS = 14 * 60 * 1000; // 14 minutes\nconst VENTILATION_CYCLE_DURATION_MS = 1 * 60 * 1000; // 1 minute\n\nasync function callService(domain: string, service: string, serviceData: object) {\n    const { haUrl, haToken } = getHaConfig();\n\n    const response = await fetch(`${haUrl}/api/services/${domain}/${service}`, {\n        method: 'POST',\n        headers: {\n            'Authorization': `Bearer ${haToken}`,\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(serviceData),\n        cache: 'no-store' // Ensure fresh calls every time\n    });\n\n    if (!response.ok) {\n        const errorBody = await response.text();\n        console.error(\"Home Assistant API kļūda:\", errorBody);\n        throw new Error(`Neizdevās sazināties ar Home Assistant. Status: ${response.status}`);\n    }\n    return response.json();\n}\n\nasync function getEntityState(entityId: string): Promise<{ state: string }> {\n    const { haUrl, haToken } = getHaConfig();\n\n    const response = await fetch(`${haUrl}/api/states/${entityId}`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${haToken}`,\n            'Content-Type': 'application/json',\n        },\n        cache: 'no-store' // Ensure fresh state is read\n    });\n\n    if (!response.ok) {\n       const errorBody = await response.text();\n       console.error(\"Home Assistant API kļūda:\", errorBody);\n       throw new Error(`Neizdevās iegūt entītijas stāvokli. Status: ${response.status}`);\n    }\n\n    return response.json();\n}\n\nasync function turnOnSwitch(entityId: string) {\n    return callService('switch', 'turn_on', { entity_id: entityId });\n}\n\nasync function turnOffSwitch(entityId: string) {\n    return callService('switch', 'turn_off', { entity_id: entityId });\n}\n\nasync function pollDoorState(targetState: 'on' | 'off', timeout = 30000, interval = 500) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeout) {\n        const doorState = await getEntityState(DOOR_SENSOR_ENTITY_ID);\n        if (doorState.state === targetState) {\n            return;\n        }\n        await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    throw new Error(`Laika limits (30s) pārsniegts, gaidot durvju stāvokli: '${targetState}'.`);\n}\n\n/**\n * Unlocks the door and waits for it to be opened.\n * Throws an error if the door is not opened within the timeout.\n */\nexport async function unlockDoorAndAwaitOpen() {\n    await turnOnSwitch(LOCK_ENTITY_ID);\n\n    try {\n        // Poll for door open status\n        await pollDoorState('on'); // 'on' usually means open for binary_sensor\n    } finally {\n        // Always turn off the switch after the process\n        await turnOffSwitch(LOCK_ENTITY_ID);\n    }\n}\n\n/**\n * Waits for the door to be closed.\n * Throws an error if the door is not closed within the timeout.\n */\nexport async function awaitDoorClose() {\n    // Poll for door close status\n    await pollDoorState('off'); // 'off' usually means closed\n}\n\n/**\n * Stops the cleaning cycle by turning off all related switches,\n * and then starts the ventilation cycle.\n */\nexport async function stopCleaningCycle() {\n    console.log(\"Beidzas tīrīšanas cikls...\");\n    try {\n        await Promise.all([\n            turnOffSwitch(HEAT_ENTITY_ID),\n            turnOffSwitch(UV_ENTITY_ID),\n            turnOffSwitch(FANS_ENTITY_ID)\n        ]);\n        console.log(\"Siltums, UV-C un ventilatori ir izslēgti. Sākas vēdināšanas cikls.\");\n        \n        // Start ventilation cycle\n        await turnOnSwitch(MOTOR_ENTITY_ID);\n        console.log(\"Motors ieslēgts uz 1 minūti.\");\n\n        // Schedule motor to turn off\n        setTimeout(async () => {\n            try {\n                await turnOffSwitch(MOTOR_ENTITY_ID);\n                console.log(\"Vēdināšanas cikls beidzies, motors izslēgts.\");\n            } catch (error) {\n                 console.error(\"Kļūda, izslēdzot motoru:\", error);\n            }\n        }, VENTILATION_CYCLE_DURATION_MS);\n\n    } catch (error) {\n        console.error(\"Kļūda, beidzot tīrīšanas ciklu:\", error);\n    }\n}\n\n/**\n * Starts the cleaning cycle and schedules it to stop.\n * This function runs on the server and is not blocking.\n */\nexport async function startCleaningCycle() {\n    console.log(\"Sākas tīrīšanas cikls servera pusē...\");\n    try {\n        await Promise.all([\n            turnOnSwitch(HEAT_ENTITY_ID),\n            turnOnSwitch(UV_ENTITY_ID),\n            turnOnSwitch(FANS_ENTITY_ID)\n        ]);\n        console.log(\"Siltums, UV-C un ventilatori ir ieslēgti.\");\n\n        // Schedule the stop function to run after the duration.\n        // This runs on the server and will not be interrupted if the user navigates away.\n        setTimeout(stopCleaningCycle, CLEANING_CYCLE_DURATION_MS);\n\n        console.log(`Tīrīšanas cikls beigsies pēc ${CLEANING_CYCLE_DURATION_MS / 1000 / 60} minūtēm.`);\n        \n    } catch (error) {\n        console.error(\"Kļūda, sākot tīrīšanas ciklu:\", error);\n        // Attempt to turn everything off in case of a partial failure\n        await stopCleaningCycle();\n        // Re-throw the error to be caught by the UI\n        throw error;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {unlockDoorAndAwaitOpen as '008df63600d91d9a8264378ee15ef35eabaca97cb7'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}